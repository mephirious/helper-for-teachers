// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.3
// source: managers.proto

package grpc

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Managers_CreateCourse_FullMethodName           = "/managers.Managers/CreateCourse"
	Managers_GetCourse_FullMethodName              = "/managers.Managers/GetCourse"
	Managers_UpdateCourse_FullMethodName           = "/managers.Managers/UpdateCourse"
	Managers_DeleteCourse_FullMethodName           = "/managers.Managers/DeleteCourse"
	Managers_ListCourses_FullMethodName            = "/managers.Managers/ListCourses"
	Managers_CreateGroup_FullMethodName            = "/managers.Managers/CreateGroup"
	Managers_GetGroup_FullMethodName               = "/managers.Managers/GetGroup"
	Managers_UpdateGroup_FullMethodName            = "/managers.Managers/UpdateGroup"
	Managers_DeleteGroup_FullMethodName            = "/managers.Managers/DeleteGroup"
	Managers_ListGroupsByCourse_FullMethodName     = "/managers.Managers/ListGroupsByCourse"
	Managers_AddGroupMember_FullMethodName         = "/managers.Managers/AddGroupMember"
	Managers_RemoveGroupMember_FullMethodName      = "/managers.Managers/RemoveGroupMember"
	Managers_ListGroupMembers_FullMethodName       = "/managers.Managers/ListGroupMembers"
	Managers_AssignCourseInstructor_FullMethodName = "/managers.Managers/AssignCourseInstructor"
	Managers_RemoveCourseInstructor_FullMethodName = "/managers.Managers/RemoveCourseInstructor"
	Managers_ListCourseInstructors_FullMethodName  = "/managers.Managers/ListCourseInstructors"
	Managers_IsUserGroupTeacher_FullMethodName     = "/managers.Managers/IsUserGroupTeacher"
	Managers_ListTeachersByCourse_FullMethodName   = "/managers.Managers/ListTeachersByCourse"
	Managers_ListStudentsByGroup_FullMethodName    = "/managers.Managers/ListStudentsByGroup"
)

// ManagersClient is the client API for Managers service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ManagersClient interface {
	// ─── Courses ─────────────────────────────────────────────────────────
	CreateCourse(ctx context.Context, in *CreateCourseReq, opts ...grpc.CallOption) (*CourseResp, error)
	GetCourse(ctx context.Context, in *GetByIdReq, opts ...grpc.CallOption) (*CourseResp, error)
	UpdateCourse(ctx context.Context, in *UpdateCourseReq, opts ...grpc.CallOption) (*CourseResp, error)
	DeleteCourse(ctx context.Context, in *GetByIdReq, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ListCourses(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ListCoursesResp, error)
	// ─── Groups (sections) ──────────────────────────────────────────────
	CreateGroup(ctx context.Context, in *CreateGroupReq, opts ...grpc.CallOption) (*GroupResp, error)
	GetGroup(ctx context.Context, in *GetByIdReq, opts ...grpc.CallOption) (*GroupResp, error)
	UpdateGroup(ctx context.Context, in *UpdateGroupReq, opts ...grpc.CallOption) (*GroupResp, error)
	DeleteGroup(ctx context.Context, in *GetByIdReq, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ListGroupsByCourse(ctx context.Context, in *ListByCourseReq, opts ...grpc.CallOption) (*ListGroupsResp, error)
	// ─── Group Membership ────────────────────────────────────────────────
	AddGroupMember(ctx context.Context, in *AddMemberReq, opts ...grpc.CallOption) (*GroupMemberResp, error)
	RemoveGroupMember(ctx context.Context, in *RemoveMemberReq, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ListGroupMembers(ctx context.Context, in *ListByGroupReq, opts ...grpc.CallOption) (*ListGroupMembersResp, error)
	// ─── Course-level Instructors ───────────────────────────────────────
	AssignCourseInstructor(ctx context.Context, in *AssignInstructorReq, opts ...grpc.CallOption) (*CourseInstructorResp, error)
	RemoveCourseInstructor(ctx context.Context, in *RemoveInstructorReq, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ListCourseInstructors(ctx context.Context, in *ListByCourseReq, opts ...grpc.CallOption) (*ListCourseInstructorsResp, error)
	// ─── Cross-Service Lookups ──────────────────────────────────────────
	IsUserGroupTeacher(ctx context.Context, in *CheckMemberReq, opts ...grpc.CallOption) (*BoolResp, error)
	ListTeachersByCourse(ctx context.Context, in *ListByCourseReq, opts ...grpc.CallOption) (*ListCourseInstructorsResp, error)
	ListStudentsByGroup(ctx context.Context, in *ListByGroupReq, opts ...grpc.CallOption) (*ListGroupMembersResp, error)
}

type managersClient struct {
	cc grpc.ClientConnInterface
}

func NewManagersClient(cc grpc.ClientConnInterface) ManagersClient {
	return &managersClient{cc}
}

func (c *managersClient) CreateCourse(ctx context.Context, in *CreateCourseReq, opts ...grpc.CallOption) (*CourseResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CourseResp)
	err := c.cc.Invoke(ctx, Managers_CreateCourse_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managersClient) GetCourse(ctx context.Context, in *GetByIdReq, opts ...grpc.CallOption) (*CourseResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CourseResp)
	err := c.cc.Invoke(ctx, Managers_GetCourse_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managersClient) UpdateCourse(ctx context.Context, in *UpdateCourseReq, opts ...grpc.CallOption) (*CourseResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CourseResp)
	err := c.cc.Invoke(ctx, Managers_UpdateCourse_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managersClient) DeleteCourse(ctx context.Context, in *GetByIdReq, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Managers_DeleteCourse_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managersClient) ListCourses(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ListCoursesResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListCoursesResp)
	err := c.cc.Invoke(ctx, Managers_ListCourses_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managersClient) CreateGroup(ctx context.Context, in *CreateGroupReq, opts ...grpc.CallOption) (*GroupResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GroupResp)
	err := c.cc.Invoke(ctx, Managers_CreateGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managersClient) GetGroup(ctx context.Context, in *GetByIdReq, opts ...grpc.CallOption) (*GroupResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GroupResp)
	err := c.cc.Invoke(ctx, Managers_GetGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managersClient) UpdateGroup(ctx context.Context, in *UpdateGroupReq, opts ...grpc.CallOption) (*GroupResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GroupResp)
	err := c.cc.Invoke(ctx, Managers_UpdateGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managersClient) DeleteGroup(ctx context.Context, in *GetByIdReq, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Managers_DeleteGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managersClient) ListGroupsByCourse(ctx context.Context, in *ListByCourseReq, opts ...grpc.CallOption) (*ListGroupsResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListGroupsResp)
	err := c.cc.Invoke(ctx, Managers_ListGroupsByCourse_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managersClient) AddGroupMember(ctx context.Context, in *AddMemberReq, opts ...grpc.CallOption) (*GroupMemberResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GroupMemberResp)
	err := c.cc.Invoke(ctx, Managers_AddGroupMember_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managersClient) RemoveGroupMember(ctx context.Context, in *RemoveMemberReq, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Managers_RemoveGroupMember_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managersClient) ListGroupMembers(ctx context.Context, in *ListByGroupReq, opts ...grpc.CallOption) (*ListGroupMembersResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListGroupMembersResp)
	err := c.cc.Invoke(ctx, Managers_ListGroupMembers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managersClient) AssignCourseInstructor(ctx context.Context, in *AssignInstructorReq, opts ...grpc.CallOption) (*CourseInstructorResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CourseInstructorResp)
	err := c.cc.Invoke(ctx, Managers_AssignCourseInstructor_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managersClient) RemoveCourseInstructor(ctx context.Context, in *RemoveInstructorReq, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Managers_RemoveCourseInstructor_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managersClient) ListCourseInstructors(ctx context.Context, in *ListByCourseReq, opts ...grpc.CallOption) (*ListCourseInstructorsResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListCourseInstructorsResp)
	err := c.cc.Invoke(ctx, Managers_ListCourseInstructors_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managersClient) IsUserGroupTeacher(ctx context.Context, in *CheckMemberReq, opts ...grpc.CallOption) (*BoolResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BoolResp)
	err := c.cc.Invoke(ctx, Managers_IsUserGroupTeacher_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managersClient) ListTeachersByCourse(ctx context.Context, in *ListByCourseReq, opts ...grpc.CallOption) (*ListCourseInstructorsResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListCourseInstructorsResp)
	err := c.cc.Invoke(ctx, Managers_ListTeachersByCourse_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managersClient) ListStudentsByGroup(ctx context.Context, in *ListByGroupReq, opts ...grpc.CallOption) (*ListGroupMembersResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListGroupMembersResp)
	err := c.cc.Invoke(ctx, Managers_ListStudentsByGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ManagersServer is the server API for Managers service.
// All implementations must embed UnimplementedManagersServer
// for forward compatibility.
type ManagersServer interface {
	// ─── Courses ─────────────────────────────────────────────────────────
	CreateCourse(context.Context, *CreateCourseReq) (*CourseResp, error)
	GetCourse(context.Context, *GetByIdReq) (*CourseResp, error)
	UpdateCourse(context.Context, *UpdateCourseReq) (*CourseResp, error)
	DeleteCourse(context.Context, *GetByIdReq) (*emptypb.Empty, error)
	ListCourses(context.Context, *emptypb.Empty) (*ListCoursesResp, error)
	// ─── Groups (sections) ──────────────────────────────────────────────
	CreateGroup(context.Context, *CreateGroupReq) (*GroupResp, error)
	GetGroup(context.Context, *GetByIdReq) (*GroupResp, error)
	UpdateGroup(context.Context, *UpdateGroupReq) (*GroupResp, error)
	DeleteGroup(context.Context, *GetByIdReq) (*emptypb.Empty, error)
	ListGroupsByCourse(context.Context, *ListByCourseReq) (*ListGroupsResp, error)
	// ─── Group Membership ────────────────────────────────────────────────
	AddGroupMember(context.Context, *AddMemberReq) (*GroupMemberResp, error)
	RemoveGroupMember(context.Context, *RemoveMemberReq) (*emptypb.Empty, error)
	ListGroupMembers(context.Context, *ListByGroupReq) (*ListGroupMembersResp, error)
	// ─── Course-level Instructors ───────────────────────────────────────
	AssignCourseInstructor(context.Context, *AssignInstructorReq) (*CourseInstructorResp, error)
	RemoveCourseInstructor(context.Context, *RemoveInstructorReq) (*emptypb.Empty, error)
	ListCourseInstructors(context.Context, *ListByCourseReq) (*ListCourseInstructorsResp, error)
	// ─── Cross-Service Lookups ──────────────────────────────────────────
	IsUserGroupTeacher(context.Context, *CheckMemberReq) (*BoolResp, error)
	ListTeachersByCourse(context.Context, *ListByCourseReq) (*ListCourseInstructorsResp, error)
	ListStudentsByGroup(context.Context, *ListByGroupReq) (*ListGroupMembersResp, error)
	mustEmbedUnimplementedManagersServer()
}

// UnimplementedManagersServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedManagersServer struct{}

func (UnimplementedManagersServer) CreateCourse(context.Context, *CreateCourseReq) (*CourseResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCourse not implemented")
}
func (UnimplementedManagersServer) GetCourse(context.Context, *GetByIdReq) (*CourseResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCourse not implemented")
}
func (UnimplementedManagersServer) UpdateCourse(context.Context, *UpdateCourseReq) (*CourseResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCourse not implemented")
}
func (UnimplementedManagersServer) DeleteCourse(context.Context, *GetByIdReq) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCourse not implemented")
}
func (UnimplementedManagersServer) ListCourses(context.Context, *emptypb.Empty) (*ListCoursesResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListCourses not implemented")
}
func (UnimplementedManagersServer) CreateGroup(context.Context, *CreateGroupReq) (*GroupResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateGroup not implemented")
}
func (UnimplementedManagersServer) GetGroup(context.Context, *GetByIdReq) (*GroupResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGroup not implemented")
}
func (UnimplementedManagersServer) UpdateGroup(context.Context, *UpdateGroupReq) (*GroupResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateGroup not implemented")
}
func (UnimplementedManagersServer) DeleteGroup(context.Context, *GetByIdReq) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteGroup not implemented")
}
func (UnimplementedManagersServer) ListGroupsByCourse(context.Context, *ListByCourseReq) (*ListGroupsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListGroupsByCourse not implemented")
}
func (UnimplementedManagersServer) AddGroupMember(context.Context, *AddMemberReq) (*GroupMemberResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddGroupMember not implemented")
}
func (UnimplementedManagersServer) RemoveGroupMember(context.Context, *RemoveMemberReq) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveGroupMember not implemented")
}
func (UnimplementedManagersServer) ListGroupMembers(context.Context, *ListByGroupReq) (*ListGroupMembersResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListGroupMembers not implemented")
}
func (UnimplementedManagersServer) AssignCourseInstructor(context.Context, *AssignInstructorReq) (*CourseInstructorResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AssignCourseInstructor not implemented")
}
func (UnimplementedManagersServer) RemoveCourseInstructor(context.Context, *RemoveInstructorReq) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveCourseInstructor not implemented")
}
func (UnimplementedManagersServer) ListCourseInstructors(context.Context, *ListByCourseReq) (*ListCourseInstructorsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListCourseInstructors not implemented")
}
func (UnimplementedManagersServer) IsUserGroupTeacher(context.Context, *CheckMemberReq) (*BoolResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsUserGroupTeacher not implemented")
}
func (UnimplementedManagersServer) ListTeachersByCourse(context.Context, *ListByCourseReq) (*ListCourseInstructorsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTeachersByCourse not implemented")
}
func (UnimplementedManagersServer) ListStudentsByGroup(context.Context, *ListByGroupReq) (*ListGroupMembersResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListStudentsByGroup not implemented")
}
func (UnimplementedManagersServer) mustEmbedUnimplementedManagersServer() {}
func (UnimplementedManagersServer) testEmbeddedByValue()                  {}

// UnsafeManagersServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ManagersServer will
// result in compilation errors.
type UnsafeManagersServer interface {
	mustEmbedUnimplementedManagersServer()
}

func RegisterManagersServer(s grpc.ServiceRegistrar, srv ManagersServer) {
	// If the following call pancis, it indicates UnimplementedManagersServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Managers_ServiceDesc, srv)
}

func _Managers_CreateCourse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateCourseReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagersServer).CreateCourse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Managers_CreateCourse_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagersServer).CreateCourse(ctx, req.(*CreateCourseReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Managers_GetCourse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByIdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagersServer).GetCourse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Managers_GetCourse_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagersServer).GetCourse(ctx, req.(*GetByIdReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Managers_UpdateCourse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateCourseReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagersServer).UpdateCourse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Managers_UpdateCourse_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagersServer).UpdateCourse(ctx, req.(*UpdateCourseReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Managers_DeleteCourse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByIdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagersServer).DeleteCourse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Managers_DeleteCourse_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagersServer).DeleteCourse(ctx, req.(*GetByIdReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Managers_ListCourses_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagersServer).ListCourses(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Managers_ListCourses_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagersServer).ListCourses(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Managers_CreateGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateGroupReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagersServer).CreateGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Managers_CreateGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagersServer).CreateGroup(ctx, req.(*CreateGroupReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Managers_GetGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByIdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagersServer).GetGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Managers_GetGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagersServer).GetGroup(ctx, req.(*GetByIdReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Managers_UpdateGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateGroupReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagersServer).UpdateGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Managers_UpdateGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagersServer).UpdateGroup(ctx, req.(*UpdateGroupReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Managers_DeleteGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByIdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagersServer).DeleteGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Managers_DeleteGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagersServer).DeleteGroup(ctx, req.(*GetByIdReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Managers_ListGroupsByCourse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListByCourseReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagersServer).ListGroupsByCourse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Managers_ListGroupsByCourse_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagersServer).ListGroupsByCourse(ctx, req.(*ListByCourseReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Managers_AddGroupMember_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddMemberReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagersServer).AddGroupMember(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Managers_AddGroupMember_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagersServer).AddGroupMember(ctx, req.(*AddMemberReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Managers_RemoveGroupMember_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveMemberReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagersServer).RemoveGroupMember(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Managers_RemoveGroupMember_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagersServer).RemoveGroupMember(ctx, req.(*RemoveMemberReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Managers_ListGroupMembers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListByGroupReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagersServer).ListGroupMembers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Managers_ListGroupMembers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagersServer).ListGroupMembers(ctx, req.(*ListByGroupReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Managers_AssignCourseInstructor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AssignInstructorReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagersServer).AssignCourseInstructor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Managers_AssignCourseInstructor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagersServer).AssignCourseInstructor(ctx, req.(*AssignInstructorReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Managers_RemoveCourseInstructor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveInstructorReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagersServer).RemoveCourseInstructor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Managers_RemoveCourseInstructor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagersServer).RemoveCourseInstructor(ctx, req.(*RemoveInstructorReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Managers_ListCourseInstructors_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListByCourseReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagersServer).ListCourseInstructors(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Managers_ListCourseInstructors_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagersServer).ListCourseInstructors(ctx, req.(*ListByCourseReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Managers_IsUserGroupTeacher_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckMemberReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagersServer).IsUserGroupTeacher(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Managers_IsUserGroupTeacher_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagersServer).IsUserGroupTeacher(ctx, req.(*CheckMemberReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Managers_ListTeachersByCourse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListByCourseReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagersServer).ListTeachersByCourse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Managers_ListTeachersByCourse_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagersServer).ListTeachersByCourse(ctx, req.(*ListByCourseReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Managers_ListStudentsByGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListByGroupReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagersServer).ListStudentsByGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Managers_ListStudentsByGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagersServer).ListStudentsByGroup(ctx, req.(*ListByGroupReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Managers_ServiceDesc is the grpc.ServiceDesc for Managers service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Managers_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "managers.Managers",
	HandlerType: (*ManagersServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateCourse",
			Handler:    _Managers_CreateCourse_Handler,
		},
		{
			MethodName: "GetCourse",
			Handler:    _Managers_GetCourse_Handler,
		},
		{
			MethodName: "UpdateCourse",
			Handler:    _Managers_UpdateCourse_Handler,
		},
		{
			MethodName: "DeleteCourse",
			Handler:    _Managers_DeleteCourse_Handler,
		},
		{
			MethodName: "ListCourses",
			Handler:    _Managers_ListCourses_Handler,
		},
		{
			MethodName: "CreateGroup",
			Handler:    _Managers_CreateGroup_Handler,
		},
		{
			MethodName: "GetGroup",
			Handler:    _Managers_GetGroup_Handler,
		},
		{
			MethodName: "UpdateGroup",
			Handler:    _Managers_UpdateGroup_Handler,
		},
		{
			MethodName: "DeleteGroup",
			Handler:    _Managers_DeleteGroup_Handler,
		},
		{
			MethodName: "ListGroupsByCourse",
			Handler:    _Managers_ListGroupsByCourse_Handler,
		},
		{
			MethodName: "AddGroupMember",
			Handler:    _Managers_AddGroupMember_Handler,
		},
		{
			MethodName: "RemoveGroupMember",
			Handler:    _Managers_RemoveGroupMember_Handler,
		},
		{
			MethodName: "ListGroupMembers",
			Handler:    _Managers_ListGroupMembers_Handler,
		},
		{
			MethodName: "AssignCourseInstructor",
			Handler:    _Managers_AssignCourseInstructor_Handler,
		},
		{
			MethodName: "RemoveCourseInstructor",
			Handler:    _Managers_RemoveCourseInstructor_Handler,
		},
		{
			MethodName: "ListCourseInstructors",
			Handler:    _Managers_ListCourseInstructors_Handler,
		},
		{
			MethodName: "IsUserGroupTeacher",
			Handler:    _Managers_IsUserGroupTeacher_Handler,
		},
		{
			MethodName: "ListTeachersByCourse",
			Handler:    _Managers_ListTeachersByCourse_Handler,
		},
		{
			MethodName: "ListStudentsByGroup",
			Handler:    _Managers_ListStudentsByGroup_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "managers.proto",
}
